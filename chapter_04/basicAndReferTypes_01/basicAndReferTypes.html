<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>basicAndReferTypes</title>
</head>
<script>
    // js不允许直接访问内存中的地址
    // 引用类型的值是保存在内存中的对象

    // 基本类型
    var person = 'hello'
    person.age = 12
    
    // 相对于没有age这个属性，也就是说给基本类型的变量设置属性是无效的
    console.log(person.age); // undefined
    console.log(person.age2); // undefined

    // 引用类型 可以添加属性和方法
    var person = new String('hello')
    person.age = 12
    console.log(person.age); // 12
</script>

<script>
    // 基本类型的变量复制的是变量本身
    // 引用类型的变量复制是变量的指针 (引用类型的变量保存在内存中，而js不能访问内存，通过指针来引用到真正的变量值)

    var classroom = new Object({
        name: 'simon'
    })
    var newClassroom = classroom // 赋值的时候不能读取内存，classroom只是内存地址的引用值

    // 但是添加/修改属性的时候可以访问到内存，所以会改变内存中的对象
    console.log(newClassroom, 'newClassroom original');
    newClassroom.name = '一年级一班'
    newClassroom.num = 11
    console.log(newClassroom, 'newClassroom before');

    newClassroom = new Object() // new了一个新对象，把新对象的内存地址的引用值赋值给了newClassroom
    newClassroom.name = '二年级一班' // newClassroom的值被覆盖了，变成了对新对象的内存地址的引用值
    console.log(newClassroom, 'newClassroom after');


</script>

<script>
    /*
        按值传递：传递【变量本身的值】

        【变量本身的值】：
            基本类型变量就是指 变量值
            引用类型变量就是指 变量值的引用

        所以：按【值】传递就是 按【变量值或者指针】传递
     */

    /*
        按引用传递：传递一个真实的内存地址
    */


    // js中给方法传递参数都是按值传递的，也就是说不能传递一个内存中的对象
    // 只能传递一个指针或者是基本类型变量值
    function add(num) {
        num += 10
        return num
    }
    var count = 20

    // 相当于把count变量的变量值20赋值给了 局部变量num
    var res = add(count)

    // num和count是相互独立的，所以num值改变了count是不会变的
    console.log(count)
    console.log(res)


    function setName(obj) { // obj是一个指针
        // obj.name = 'simon'

        // 将这个指针赋值给newObj 
        // newObj也指向了这个obj指向的内存地址
        var newObj = obj
        newObj.hobby = 'run'
        return newObj
    }
    var person = new Object()

    // person的值是一个指针，它指向一个内存地址，这个地址中保存着一个对象
    // 相当于把person变量的指针赋值给了obj，又因为添加/编辑属性会影响到内存中的对象
    // 所以对obj变量添加属性，就会修改obj变量指向的对象

    console.log(setName(person));


    console.log(person, 'person');


        function setName2(obj) {
            // 拿到的【obj变量】是一个内存地址的指针
            // 修改对象可以访问到内存，因此会改变【obj变量】指向的内存中的值
            // 此时person2变量和obj指向的是同一个地址，所以person2的值被影响到了
            obj.name = 'simon'

            // 重新给【obj变量】赋值一个新对象
            // 此时【obj变量】指向了一个新的内存地址
            // 此时obj变量指向的内存地址如果发生变化，不会影响person2了
            obj = new Object({a:2})

            obj.name = 'hahahaha'
        }
        var person2 = new Object({name:'dd'})
        setName2(person2)
        console.log(person2);


</script>

<script>
    // 检测类型
    // instance of操作符用来检测对象是什么类型的对象
    // 所有引用类型的值都是Object的实例
    // 基本数据类型全部返回false，因为他们根本就不是对象，不属于任何对象
</script>

<body>

</body>

</html>