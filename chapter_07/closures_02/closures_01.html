<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>最典型的闭包理解</title>
</head>

<body>

</body>

<script>
    /*
        匿名函数：指function关键字后没有带函数名的函数
        闭包：指有权访问另一个函数作用域中的变量的函数
    */

    function fun01() {
        var num = 1
        return function (n) {
            num += n
            console.log(num, 'num');
        }
    }
    var add = fun01()
    add(1)
    add(1)

    // 创建add这个函数，这个函数在全局，不会被销毁
    // 函数创建的时候会创建一个作用域链，这个作用域链被保存到add的[[ scope ]]属性中
    // 而在这个例子中，这个作用域链中会包含两个指针，一个指针指向window对象，另一个指针指向fun01的AO对象
    // 因此即便fun01执行完毕，它的AO对象也不会被释放，因为它被一个全局变量的某个属性引用着

    // 执行第一次add，因为add函数的作用域链中有num变量，因此可以修改它
    // 再次执行add，作用域链中的num变量依然在

    // 如何消除呢？因为add函数有属性引用着fun01的AO对象
    // 因此add=null 就可以释放add函数，从而释放fun01的AO对象


    // 因此所谓闭包，就是一个函数，通过定义一个暂时不会被程序回收的变量，把自身赋值给这个变量
    // 而这个变量创建的时候会自带scope属性，只要这个scope属性中有其他函数的AO，那么执行这个变量的时候
    // 就可以访问到其他函数中定义的变量了




    // 不理解就看下面的解释：
    /*
        js分为【全局执行环境】和【函数执行环境】，而每一个执行环境中都有一个变量对象
        执行环境中定义的所有变量和函数都会保存在这个变量对象中

        当在某个环境中的代码执行完毕，这个环境就会被销毁，这个环境中的变量对象也会被销毁。
        全局环境比只有关闭网页才会销毁。

        每个环境都会有一个作用域链
            1. 它的作用是为了保证在每一个环境中访问变量的顺序
            2. 它是一个指针列表，每个指针指向某个执行环境中的变量对象
            3. 在某个环境中，访问变量按照作用域链的顺序访问
        【全局执行环境】的作用域链：window对象
        【函数执行环境】的作用域链：
            1. 在创建函数的时候，会创建包含这个函数的各个执行环境的变量对象组成的作用域链
               这个作用域链是一个指针列表，指向各个执行环境的变量对象
            2. 执行的时候创建出函数本身的变量对象，最后组成作用域链


        fun01的作用域链
            创建的时候，创建了一个作用域链，这个作用域链只有一个指针，它指向window对象
                而fun01有一个scope属性，它引用着fun01的作用域链
            执行的时候，又给作用域链增加了一个指针：fun01的AO
            最终fun01的作用域链：fun01的AO -> window对象

            执行完毕后
                1. 全局变量add指向返回的匿名函数（这一步触发了匿名函数的创建过程）

                    创建匿名函数的时候，创建了匿名函数的一个作用域链
                        这个作用域链有2个指针，fun02的AO -> window对象
                        而匿名函数有一个scope属性，它引用着匿名函数的作用域链
                    因此当创建匿名函数结束后，全局变量add有一个scope属性引用着匿名函数的作用域链
                    而匿名函数的作用域链又引用着fun02的AO和window对象
                    这导致如果全局变量add没有被销毁，那么fun02的AO会一直在内存中
                2. fun01执行完毕，fun01环境被销毁
                3. fun01的AO对象正常也被销毁

                   但是因为步骤1，fun01的AO不会被销毁

        add函数执行（其实是匿名函数执行）时候创建出匿名函数本身的变量对象，然后添加到匿名函数的作用域链中
            匿名函数作用域链： 匿名函数的AO -> fun01的AO -> window对象
        因此当匿名函数执行的时候访问num这个变量时，就会在它的作用域链中寻找，发现在第二个指针引用的对象（fun01的AO）中，他就会使用并更改它
        再次执行，因为scope属性没有发生变化，这时候的作用域链后面两个指针和前面的是一样的，因此访问到的变量也是修改过后的

    */
</script>

</html>