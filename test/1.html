<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /*
        
            为什么会有回调函数？
            当某段程序执行需要非常长时间的时候，我们希望它不要阻塞主程序，让它异步的执行
            当他执行完再执行我们希望他执行的操作

        */


        /*

            比如我们卖奶茶：机器制作奶茶 -> 卖奶茶
            当制作奶茶需要半个小时的时候，我们并不想啥都不干，傻傻等它做完。

            我们想制作奶茶的时候我们可以同步做别的事情，
            机器制作奶茶这个程序不要打扰我们的主程序（打游戏享受生活）

            同时，奶茶什么时候制作完毕我们也不希望关心，在用机器制作奶茶的时候，
            我们再给这个机器一个功能，告诉机器制作奶茶完毕就送到窗口售卖
            这样，制作奶茶这件事情不会打扰我们打游戏，制作完毕后的事情因为我们提前准备好了，
            也不需要我们操心，完美！

            这里有两个关键点：
                1:制作奶茶这个动作需要设计成异步，不能影响主程序（如果影响了打游戏，他就是失败的机器！）
                2:但是因为它是异步的，它什么时候结束我们并不知道，这就导致一个问题。
                    如果有程序依赖它的执行，就会不知道什么时候执行（不知道什么时候可以卖奶茶）
                3:但是我们又不想关心他什么时候执行完毕，因此回调函数就被设计出来了
                4:往这个异步程序里加入一段固定的程序，当异步程序执行完毕就执行这段程序，这段程序就是回调函数


        */

        // 制作奶茶
        function makeTea(callback) {
            // 制作奶茶的程序
            //....

            // 奶茶已经制作好啦
            // 最后执行回调函数
            callback()
        }

        // 卖奶茶
        function sellTea() { }

        makeTea(sellTea)


    </script>



    <script>
        /*
        
            但是回调函数也有缺点：
                1.当多个异步程序依次依赖的时候，就会导致回调地狱
                2.当回调函数传入其他人制作的异步函数的时候，什么时候执行、会执行几次等等都不可控，可能导致意外的情况
                3.因为是异步任务，很难捕捉程序错误
                4.并行问题，当某段程序依赖多个异步任务才能执行的时候，就必须知道每一个移步任务是否执行完毕，这不好处理

        */

    </script>

    <script>

         /*
            回调地域问题：
                1.不好理解
                2.不好维护
        
            制作奶茶 -> 卖奶茶

            收钱 -> 制作奶茶 -> 卖奶茶

            假设当制作奶茶还依赖着收钱这个程序，同时我们希望收钱也是异步的不能影响我们打游戏

        */

        function getMoney(callback) {
            // 收钱的程序
            //....

            // 钱已经收好啦
            // 最后执行回调函数
            callback()
        }

        // 制作奶茶
        function makeTea(callback) {
            // 制作奶茶的程序
            //....

            // 奶茶已经制作好啦
            // 最后执行回调函数
            callback()
        }

        function sellTea() { }

        getMoney(function () {
            makeTea(function () {
                sellTea()
            })
        })

        // 上面只是2层依赖，如果更多的话，看起来会更不好理解
        // 同时，想修改回调函数的功能（更新迭代制作奶茶的机器），就只能修改机器
        // 其实我们希望不要影响原来已经制作好的代码，希望制作奶茶这个程序是高度抽象，可以灵活地扩展功能
        // 而不是每次增加功能的时候，只能直接修改程序本身，这样子影响范围就会比较大
        // 既有的系统中，可能有很多地方调用了老的制作奶茶方法，直接修改它会影响到这些地方
    </script>

    <script>
        /*
        
            错误跟踪问题
        
        */

        const time = (callback) => {
            setTimeout(() => {
                try {
                    console.log(aaaa) // aaaa未定义
                    callback()
                } catch (err) {
                    throw err
                }
            }, 1000)
        }

        const cb = () => {
            console.log('success')
        }

        // try...catch无法捕获到time中的报错
        try {
            time(cb)
        } catch (err) {
            console.log('err', err)
        }

        // 传入的回调函数没有执行，但是外部获取不到内部发生的错误，导致没法排查错误
        // 为什么捕获不到
    </script>
</body>

</html>